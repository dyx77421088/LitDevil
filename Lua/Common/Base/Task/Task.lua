-- Task.lua
-- @author: zhangliang
-- @note: Task base class definition
-- 2021.7.29
local TaskAux = require "Base.Task.TaskAux"

local Log = TaskAux.Log
local LogVerbose = TaskAux.LogVerbose
local LogError = TaskAux.LogError
local TaskStatus = TaskAux.TaskStatus

local _M = BaseClass("Task")
_M.IsTask = true

function _M.__ctor(self)
    self.id = nil                               -- Task id generated by TaskMgr
    self.status = TaskStatus.None               -- Task status
    self.delayOneFrame = false                  -- execute _OnStart in next frame
    self.updateTag = TaskAux.UpdateTag.Update   -- indicates when to wake up a Task in engine update loop
    self.children = nil                         -- List<Task>, children Tasks that depend on this Task
    self.dependencies = nil                     -- List<Task>, Tasks that this Task depends on
    self.onDoneCallback = nil                   -- finish callback
    self.error = nil                            -- error message
    self.result = nil                           -- task result
end

function _M.Id(self) return self.id end
function _M.HasAdded(self) return math.toboolean(self.id) end
function _M.Status(self) return self.status end
function _M.IsDone(self) return self.status > TaskStatus.Running end
function _M.HasError(self) return self.error ~= nil end
function _M.Error(self) return self.error end
function _M.ToString(self) return string.format("%s:%s", self.clsname, self.id) end

-- Run <otherTask> when this Task is done, just another way to establish task dependency
-- otherTask: Task
function _M.Then(self, otherTask)
    if TaskAux.IsTask(otherTask) then
        Globals.taskMgr:_AddDependency(otherTask, self)
    end
end

-- Start Task at next frame
function _M.DelayOneFrame(self)
    self.delayOneFrame = true
    return self
end

-- Callback when Task is done(Succes, Error, Interrupt)
function _M.OnDone(self, callback)
    self.onDoneCallback = callback
    return self
end

-- Get Task execution results
-- @return: return value is a table, if you call this function to get results, you'll have to unpack it manually.
-- @exception:
--  raise error when trying to get result from a running task.
--  use pcall or check Status first.
function _M.GetResults(self)
    if self.status == TaskStatus.Success then
        return self.result
    elseif (not self:IsDone()) then
        error(string.format("[%s:%d] Unable to <GetResult> when <Task> is still running", self.clsname, self.id))
    end
end

-- Interrupt the Task halfway, No effect if Task has finish running
-- derived class can do clean-up in OnInterrupt function
function _M.Interrupt(self)
    if (not self:IsDone()) then
        self.status = TaskStatus.Interrupt
        self:_PCallTaskFunction("_OnInterrupt")
    end
end

-- #region internal
function _M._HasChildren(self) return self.children and #self.children > 0 end
function _M._HasDependencies(self) return self.dependencies and #self.dependencies > 0 end

-- [internal]
function _M._PCallTaskFunction(self, funcName)
    local ret = false
    local func = self[funcName]
    if func then
        local ok, err = xpcall(
            function() func(self) end,
            debug.traceback)

        LogVerbose(self, funcName, ok)

        if (not ok) then
            if (not self:IsDone()) then
                self:_Finish(TaskStatus.Error, err)
            end
        else
            ret = true
        end
    end
    return ret
end

-- [internal]
function _M._Start(self)
    if self.status == TaskStatus.None then
        self:_PCallTaskFunction("_OnStart")
        if (not self:IsDone()) then
            self.status = TaskStatus.Running
        end
    end
end

-- [internal]
function _M._Update(self)
    if self.status == TaskStatus.Running then
        self:_PCallTaskFunction("_OnUpdate")
    end
end

-- [internal]
function _M._Finish(self, statusCode, ...)
    Log(self, "Finish", statusCode, ...)
    if self:IsDone() or statusCode <= TaskStatus.Running then
        return
    end

    if statusCode == TaskStatus.Interrupt then
        self:Interrupt()
    else
        self.status = statusCode
        if statusCode == TaskStatus.Success then
            self.result = (select("#", ...) > 0) and { ... } or G_EmptyTable
        else
            self.error = select(1, ...)
            LogError(self, self.error)
        end
        self:_PCallTaskFunction(self, "_OnFinish")
    end

    if self.onDoneCallback then
        self.onDoneCallback(self)
    end
end

-- [internal, override] Called before the first _OnUpdate
function _M._OnStart(_)
end

-- [internal, override] Update every frame
function _M._OnUpdate(_)
end

-- [internal, override] Called when Task is finished
-- won't be called if Task is interrupted, _OnInterrupt is called instead
function _M._OnFinish(_)
end

-- [internal, override] Do clean-up in this function when Task is interrupted halfway.
function _M._OnInterrupt(_)
end
-- #endregion internal

return _M